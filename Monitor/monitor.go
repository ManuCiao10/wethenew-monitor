package monitor

import (
	// "bytes"
	"bytes"
	"encoding/json"
	// "fmt"
	"strconv"

	// "net/http/cookiejar"
	"os"

	// "os"
	// "strconv"
	// "time"

	// "fmt"
	"io"
	"log"
	"main/data"

	// "os"
	// "strconv"
	"time"

	// "main/discord"

	http "github.com/bogdanfinn/fhttp"
	tls_client "github.com/bogdanfinn/tls-client"
)

type ID struct {
	Results []struct {
		ID          int    `json:"id"`
		Name        string `json:"name"`
		Image       string `json:"image"`
		ProductType string `json:"productType"`
		SellNows    []struct {
			ID    int    `json:"id"`
			Size  string `json:"size"`
			Price int    `json:"price"`
		} `json:"sellNows"`
	} `json:"results"`
}

func SaveSlice(class data.Info) []int {
	var slice []int

	for _, v := range class.Results {
		if v.ID != 275 {
			slice = append(slice, v.ID)
		}
	}
	return slice
}

func Contains(s []int, id int) bool {
	for _, v := range s {
		if v == id {
			return true
		}
	}
	return false
}

func Webhook(client tls_client.HttpClient, new_id ID, idx int) {
	type Author struct {
		Name    string `json:"name"`
		URL     string `json:"url"`
		IconURL string `json:"icon_url"`
	}

	type Fields struct {
		Name   string `json:"name"`
		Value  string `json:"value"`
		Inline bool   `json:"inline,omitempty"`
	}
	type Thumbnail struct {
		URL string `json:"url"`
	}

	type Image struct {
		URL string `json:"url"`
	}

	type Footer struct {
		Text    string `json:"text"`
		IconURL string `json:"icon_url"`
	}
	type Embeds struct {
		Author      Author    `json:"author"`
		Title       string    `json:"title"`
		URL         string    `json:"url"`
		Description string    `json:"description"`
		Color       int       `json:"color"`
		Fields      []Fields  `json:"fields"`
		Thumbnail   Thumbnail `json:"thumbnail"`
		Image       Image     `json:"image"`
		Footer      Footer    `json:"footer"`
	}
	type AutoGenerated struct {
		Username  string   `json:"username"`
		AvatarURL string   `json:"avatar_url"`
		Content   string   `json:"content"`
		Embeds    []Embeds `json:"embeds"`
	}

	n_size := len(new_id.Results[idx].SellNows)
	var fields []Fields
	for i := 0; i < n_size; i++ {
		fields = append(fields, Fields{
			Name:   "Payout",
			Value:  "[" + strconv.Itoa(new_id.Results[idx].SellNows[i].Price) + " â‚¬" + " | " + new_id.Results[idx].SellNows[i].Size + "]" + "(" + "https://sell.wethenew.com/sell-now/" + strconv.Itoa(new_id.Results[idx].SellNows[i].ID) + "?holding-Lab" + ")",
			Inline: true,
		})
	}
	// fields = append(fields, Fields{
	// 	Name:   "Product Type",
	// 	Value:  new_id.Results[idx].ProductType,
	// 	Inline: true,
	// })

	time := time.Now().Format("15:04:05")
	payload := &AutoGenerated{
		Username:  "Wethenew Monitor",
		AvatarURL: "https://cdn.discordapp.com/attachments/965899789021642752/965899835570016286/DBFF8755-874B-4436-B79A-0C02DDBBEBBA.jpg",
		Content:   "",
		Embeds: []Embeds{
			{
				Title: new_id.Results[idx].Name,
				// Description: "Sell Now",
				Color:  7243100,
				Fields: fields,
				Thumbnail: Thumbnail{
					URL: new_id.Results[idx].Image,
				},
				Footer: Footer{
					IconURL: "https://cdn.discordapp.com/attachments/965899789021642752/965899835570016286/DBFF8755-874B-4436-B79A-0C02DDBBEBBA.jpg",
					Text:    "Wethenew | Holding-Lab " + time,
				},
			},
		},
	}
	// fmt.Println(payload)
	payloadBuf := new(bytes.Buffer)
	_ = json.NewEncoder(payloadBuf).Encode(payload)

	webhookURL := os.Getenv("DISCORD_WEBHOOK_URL_TEST")

	if webhookURL == "" {
		panic("SET DISCORD_WEBHOOK_URL ENV VAR")
	}
	SendWebhook, err := http.NewRequest("POST", webhookURL, payloadBuf)
	if err != nil {
		panic(err)
	}
	SendWebhook.Header.Set("content-type", "application/json")

	sendWebhookRes, err := client.Do(SendWebhook)
	if err != nil {
		panic(err)
	}
	if sendWebhookRes.StatusCode != 204 {
		log.Fatal("Webhook failed to send")
	}
	defer sendWebhookRes.Body.Close()
}

func MonitorProducts(class data.Info, client tls_client.HttpClient) {
	url := "https://api-sell.wethenew.com/sell-nows?skip=0&take=50"
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal(err)
	}
	req.Header = http.Header{
		"Accept":          {"application/json, text/plain, */*"},
		"accept-language": {"it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7,de;q=0.6,fr;q=0.5"},
		"user-agent":      {"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36"},
		http.HeaderOrderKey: {
			"Accept",
			"accept-language",
			"user-agent",
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	var new_id ID
	if err := json.Unmarshal(body, &new_id); err != nil {
		log.Fatal(err)
	}
	Slice := SaveSlice(class) //TRY TO USE THE NEW_ID TO ADD THE FIRST TIME ALL THE PRODUCTS AND AFTER USEA WHILE LOOP OR A TIMER OUT FOR REQUEST

	for idx, v := range new_id.Results {
		if !Contains(Slice, v.ID) {
			Slice = append(Slice, v.ID)
			Webhook(client, new_id, idx)
		}
	}

}

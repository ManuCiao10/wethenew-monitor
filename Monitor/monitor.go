package monitor

import (
	// "bytes"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"main/data"

	// "os"
	// "strconv"
	// "time"

	// "main/discord"

	http "github.com/bogdanfinn/fhttp"
	tls_client "github.com/bogdanfinn/tls-client"
)

// type ID struct {
// 	New_ID    int    `json:"id"`
// }

type ID struct {
	Results []struct {
		ID          int    `json:"id"`
		Brand       string `json:"brand"`
		Name        string `json:"name"`
		Image       string `json:"image"`
		ProductType string `json:"productType"`
		SellNows    []struct {
			ID    int    `json:"id"`
			Size  string `json:"size"`
			Price int    `json:"price"`
		} `json:"sellNows"`
	} `json:"results"`
}

func SaveSlice(class data.Info) []int {
	var slice []int

	for _, v := range class.Results {
		slice = append(slice, v.ID)
	}
	return slice
}

var client = &http.Client{}

func Contains(s []int, id int) bool {
	for _, v := range s {
		if v == id {
			return true
		}
	}
	return false
}

func Webhook(new_id ID, idx int) {
	type Author struct {
		Name    string `json:"name"`
		URL     string `json:"url"`
		IconURL string `json:"icon_url"`
	}

	type Fields struct {
		Name   string `json:"name"`
		Value  string `json:"value"`
		Inline bool   `json:"inline,omitempty"`
	}
	type Thumbnail struct {
		URL string `json:"url"`
	}

	type Image struct {
		URL string `json:"url"`
	}

	type Footer struct {
		Text    string `json:"text"`
		IconURL string `json:"icon_url"`
	}
	type Embeds struct {
		Author      Author    `json:"author"`
		Title       string    `json:"title"`
		URL         string    `json:"url"`
		Description string    `json:"description"`
		Color       int       `json:"color"`
		Fields      []Fields  `json:"fields"`
		Thumbnail   Thumbnail `json:"thumbnail"`
		Image       Image     `json:"image"`
		Footer      Footer    `json:"footer"`
	}
	type AutoGenerated struct {
		Username  string   `json:"username"`
		AvatarURL string   `json:"avatar_url"`
		Content   string   `json:"content"`
		Embeds    []Embeds `json:"embeds"`
	}
	// fmt.Printf(new_id.Results[idx].Name)

	// time := time.Now().Format("15:04:05")
	// payload := &AutoGenerated{
	// 	Username:  "Wethenew Monitor",
	// 	AvatarURL: "https://cdn.discordapp.com/attachments/965899789021642752/965899835570016286/DBFF8755-874B-4436-B79A-0C02DDBBEBBA.jpg",
	// 	Content:   "",
	// 	Embeds: []Embeds{
	// 		{
	// 			Title: product.(map[string]interface{})["Name"].(string),
	// 			// Description: "Sell Now",
	// 			Color: 2895667,
	// 			Fields: []Fields{
	// 				{
	// 					Name:   "ProductType",
	// 					Value:  productType,
	// 					Inline: true,
	// 				},
	// 				{
	// 					Name:   "Sizes",
	// 					Value:  "[" + class.Results[0].SellNows[0].Size + " | " + strconv.Itoa(class.Results[0].SellNows[0].Price) + " â‚¬" + "]" + "(" + fmt.Sprintf("https://sell.wethenew.com/sell-now/%d?holding-Lab", class.Results[0].SellNows[0].ID) + ")",
	// 					Inline: true,
	// 				},
	// 			},
	// 			Thumbnail: Thumbnail{
	// 				URL: class.Results[0].Image,
	// 			},
	// 			Footer: Footer{
	// 				IconURL: "https://cdn.discordapp.com/attachments/965899789021642752/965899835570016286/DBFF8755-874B-4436-B79A-0C02DDBBEBBA.jpg",
	// 				Text:    "Wethenew | Holding-Lab " + time,
	// 			},
	// 		},
	// 	},
	// }
	// fmt.Println(payload)
	// payloadBuf := new(bytes.Buffer)
	// _ = json.NewEncoder(payloadBuf).Encode(payload)

	// webhookURL := os.Getenv("DISCORD_WEBHOOK_URL_TEST")

	// if webhookURL == "" {
	// 	panic("SET DISCORD_WEBHOOK_URL ENV VAR")
	// }
	// SendWebhook, err := http.NewRequest("POST", webhookURL, payloadBuf)
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// SendWebhook.Header.Set("content-type", "application/json")

	// sendWebhookRes, err := client.Do(SendWebhook)
	// if err != nil {
	// 	log.Fatal(err)
	// }
	// if sendWebhookRes.StatusCode != 204 {
	// 	log.Fatal("Webhook failed to send")
	// }
	// defer sendWebhookRes.Body.Close()
}

func MonitorProducts(class data.Info, client tls_client.HttpClient) {
	url := "https://api-sell.wethenew.com/sell-nows?skip=0&take=50"
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal(err)
	}
	req.Header = http.Header{
		"Accept":          {"application/json, text/plain, */*"},
		"accept-language": {"it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7,de;q=0.6,fr;q=0.5"},
		"user-agent":      {"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36"},
		http.HeaderOrderKey: {
			"Accept",
			"accept-language",
			"user-agent",
		},
	}
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()
	body, _ := io.ReadAll(resp.Body)
	var new_id ID
	if err := json.Unmarshal(body, &new_id); err != nil {
		log.Fatal(err)
	}
	// fmt.Printf(new_id.Results[0].Name)
	Slice := SaveSlice(class) //TRY TO USE THE NEW_ID TO ADD THE FIRST TIME ALL THE PRODUCTS AND AFTER USEA WHILE LOOP OR A TIMER OUT FOR REQUEST
	// Slice = append(Slice, 275)
	// Slice[0] = 275
	fmt.Print(Slice)
	for idx, v := range new_id.Results {
		for _, v := range v.SellNows {
			fmt.Println(v.ID) // NEED TO FIXXX
			if Contains(Slice, v.ID) {
				Slice = append(Slice, v.ID)
				Webhook(new_id, idx)
			}

		}
	}
}
